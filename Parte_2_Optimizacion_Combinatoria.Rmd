---
title: "Parte 2: Optimizacion Combinatoria"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

------------------------------------------------------------------------

En este documento se resuelve el problema del vendedor viajero visitando las 13 ciudades principales de Colombia. Para encontrar la mejor ruta se utilizan dos métodos de optimización: un Algoritmo Genético y un Algoritmo de Colonias de Hormigas. Se construye una matriz de costos en pesos colombianos, donde todo se traduce a valores monetarios: el costo del combustible según la distancia recorrida, el valor de los peajes y el tiempo de trabajo del vendedor (convertido a costo por hora). Al final, se incluye una visualización del recorrido óptimo sobre el mapa de Colombia y un GIF que muestra paso a paso cómo se construye esa ruta.

------------------------------------------------------------------------

## Instalación y carga de paquetes

```{r eval=FALSE, message=FALSE, warning=FALSE, include=FALSE}
# Ejecutar si no se tienen instalados los paquetes
install.packages("dplyr")
install.packages(c("ggplot2", "gganimate", "transformr", "gifski"))
install.packages("leaflet")
```

```{r message=FALSE, warning=FALSE}
# Cargar paquetes necesarios
library(dplyr)
library(ggplot2)
library(gganimate)
library(leaflet)
```

------------------------------------------------------------------------

## Ciudades principales de Colombia

Creamos un `data.frame` con las 13 ciudades principales de Colombia y sus respectivas coordenadas geográficas (latitud y longitud).

```{r}
ciudades <- data.frame(
  ciudad = c("Bogotá", "Medellín", "Cali", "Barranquilla", "Cartagena", 
             "Bucaramanga", "Pereira", "Manizales", "Ibagué", "Pasto",
             "Cúcuta", "Montería", "Santa Marta"),
  lat = c(4.7110, 6.2442, 3.4516, 10.9639, 10.3910,
          7.1193, 4.8133, 5.0703, 4.4389, 1.2136,
          7.8941, 8.7479, 11.2408),
  lon = c(-74.0721, -75.5812, -76.5319, -74.7964, -75.4794,
          -73.1227, -75.6961, -75.5138, -75.2322, -77.2811,
          -72.5050, -75.8814, -74.1990)
)

ciudades_nombres <- ciudades$ciudad
ciudades_cantidad <- nrow(ciudades)
```

------------------------------------------------------------------------

Para obtener las matrices de distancias, de horas y de precios de peajes entre cada par de ciudades, se hace uso del siguiente servicio web que pertenece al Ministerio de Transporte de Colombia. Esta es una fuente muy confiable ya que es gubernamental.

-   <https://plc.mintransporte.gov.co/Estad%C3%ADsticas/Carga-Modo-Terrestre/Peajes>

Obtener la información de la anterior fuente fué la mejor alternativa debido a la confianza de los datos. Lamentablemente, no es una API donde se pueda obtener esta información a partir de consultas, tampoco se puede descargar la matriz con todos los datos. Para obtener estos datos, manualmente se tuvo que ingresar cada par de ciudades para obtener la información de la distancia, del tiempo promedio en el mejor de los casos y del costo de peajes.

------------------------------------------------------------------------

## Matriz de horas entre cada par de ciudades

```{r}

horas_vector <- c(
  0, 5.83, 5.85, 12.03, 12.52, 5.83, 4.08, 4.2, 2.95, 9.42, 7.43, 9.95, 11.28, 5.83, 0, 5.20, 8.33, 7.53, 5.17, 2.63, 2.55, 4.12, 9.35, 7.85, 4.95, 9.40, 5.77, 5.20, 0, 13.55, 12.73, 9.03, 2.75, 3.27, 3.23, 4.57, 11.73, 10.17, 13.57, 12.03, 8.33, 13.55, 0, 1.6, 6.88, 10.98, 10.90, 11.52, 17.70, 8.30, 4.28, 1.33, 12.52, 7.53, 12.73, 1.60, 0, 7.38, 10.18, 10.10, 11.65, 16.88, 8.78, 3.15, 2.87, 5.83, 5.17, 9.03, 6.88, 7.38, 0, 6.48, 6.03, 6.23, 13.18, 2.68, 8.32, 6.13, 4, 2.63, 2.75, 10.98, 10.18, 6.48, 0, 0.7, 1.47, 6.09, 9.17, 7.60, 11.02, 4.20, 2.55, 3.27, 10.90, 10.10, 6.03, 0.70, 0, 2.18, 7.42, 8.73, 7.52, 10.57, 2.95, 4.20, 3.32, 11.52, 11.75, 6.23, 1.55, 2.27, 0, 7.47, 8.92, 9.17, 10.77, 9.42, 9.35, 4.93, 17.70, 16.88, 13.18, 6.90, 7.42, 7.38, 0, 15.47, 14.32, 17.72, 7.43, 7.85, 11.73, 8.30, 8.78, 2.68, 9.17, 8.73, 8.92, 15.47, 0, 9.72, 7.55, 9.95, 4.95, 10.17, 4.28, 3.15, 8.32, 7.60, 7.52, 9.08, 14.32, 9.72, 0, 5.33, 11.28, 9.40, 13.57, 1.33, 2.87, 6.13, 11.02, 10.57, 10.77, 17.72, 7.55, 5.33, 0
)

horas_matriz <- matrix(
  horas_vector, 
  nrow = ciudades_cantidad, 
  ncol = ciudades_cantidad, 
  byrow = TRUE,
  dimnames = list(ciudades_nombres, ciudades_nombres)
)

horas_matriz <- horas_matriz * 1.35
```

-   Se hace un aumento del 35 % en las horas que tomaría cada recorrido entre dos ciudades para tener en cuenta posibles retrazos por algún tipo de imprevisto o eventualidad.

### Visualización parcial de la matriz

A continuación, mostramos una parte de la matriz de horas para validar los resultados.

```{r}
round(horas_matriz[1:5, 1:5], 1)
```

------------------------------------------------------------------------

## Matriz de distancias entre cada par de ciudades

```{r}

distancias_viales_vector <- c(
  0.0, 417.42, 447.76, 971.37, 1038.66, 402.10, 309.80, 292.91, 196.75, 770.34, 577.67, 804.78, 927.16, 417.42, 0.0, 414.42, 695.13, 647.92, 398.48, 210.94, 196.73, 323.95, 793.31, 595.77, 402.49, 787.97, 439.94, 414.42, 0.0, 1109.55, 1062.34, 766.71, 207.98, 254.40, 250.98, 371.34, 964.00, 816.91, 1197.26, 971.37, 695.13, 1109.55, 0.0, 128.49, 575.06, 906.07, 891.87, 998.29, 1488.44, 71.23, 348.61, 98, 1038.66, 647.92, 1062.34, 128.49, 0.0, 642.35, 858.86, 844.66, 971.88, 1441.23, 777.52, 272.17, 230.72, 402.10, 398.48, 761.23, 575.06, 642.35, 0.0, 557.75, 511.80, 523.53, 1140.12, 197.29, 714.89, 530.85, 301.98, 210.94, 207.98, 906.07, 858.86, 557.75, 0.0, 50.3, 113.02, 586.87, 755.05, 613.43, 988.30, 292.91, 196.73, 254.40, 891.87, 844.66, 511.80, 50.93, 0.0, 163.94, 633.30, 709.09, 599.23, 942.35, 196.75, 331.77, 258.80, 998.29, 979.70, 523.53, 120.84, 171.76, 0.0, 637.69, 720.82, 734.27, 954.07, 770.34, 793.31, 384.17, 1488.44, 1441.23, 1145.60, 586.87, 633.30, 629.87, 0.0, 1347.89, 1195.80, 1576.15, 577.67, 595.77, 958.52, 710.23, 777.52, 197.29, 755.05, 709.09, 720.82, 1347.89, 0.0, 850.06, 666.02, 804.78, 402.49, 816.91, 348.61, 272.17, 714.89, 613.43, 599.23, 726.45, 1195.80, 850.06, 0.0, 441.44, 927.16, 787.97, 1191.78, 98, 230.72, 530.85, 988.30, 942.35, 954.07, 1570.67, 666.02, 441.44, 0.0
)

distancias_viales_matriz <- matrix(
  distancias_viales_vector, 
  nrow = ciudades_cantidad, 
  ncol = ciudades_cantidad, 
  byrow = TRUE,
  dimnames = list(ciudades_nombres, ciudades_nombres)
)
```

### Visualización parcial de la matriz

A continuación, mostramos una parte de la matriz de distancias viales (en km) para validar los resultados.

```{r}
round(distancias_viales_matriz[1:5, 1:5], 1)
```

------------------------------------------------------------------------

## Matriz de precios de peajes entre cada par de ciudades

```{r}

peajes_vector <- c(
  0, 98400, 119600, 123800, 122300, 51500, 82900, 59700, 53100, 93600, 41200, 199600, 103600, 98400, 0, 138900, 145600, 133700, 68800, 82400, 66300, 112200, 151100, 90000, 101200, 165800, 119600, 138900, 0, 284500, 272600, 128100, 56500, 72600, 66500, 34300, 149300, 240100, 190400, 123800, 145600, 284500, 0, 23100, 94000, 228000, 211900, 144100, 296700, 76300, 57300, 20200, 122300, 133700, 272600, 23100, 0, 92500, 216100, 200000, 245900, 284800, 74800, 75500, 43300, 51500, 68800, 120500, 94000, 92500, 0, 64000, 47900, 61600, 132700, 21200, 105300, 73800, 82900, 82400, 56500, 228000, 216100, 64000, 0, 16100, 29800, 68700, 85200, 183600, 126300, 59700, 66300, 72600, 211900, 200000, 47900, 16100, 0, 45900, 84800, 69100, 167500, 110200, 53100, 112200, 66500, 144100, 245900, 61600, 29800, 45900, 0, 78700, 82800, 213400, 123900, 93600, 151100, 34300, 296700, 284800, 140300, 68700, 84800, 78700, 0, 146000, 252300, 202600, 41200, 90000, 141700, 76300, 74800, 21200, 85200, 69100, 82800, 146000, 0, 87600, 56100, 199600, 101200, 240100, 57300, 75500, 105300, 183600, 167500, 213400, 252300, 87600, 0, 77500, 103600, 165800, 182800, 20200, 43300, 73800, 126300, 110200, 123900, 195000, 56100, 77500, 0
)

peajes_matriz <- matrix(
  peajes_vector, 
  nrow = ciudades_cantidad, 
  ncol = ciudades_cantidad, 
  byrow = TRUE,
  dimnames = list(ciudades_nombres, ciudades_nombres)
)
```

### Visualización parcial de la matriz

A continuación, mostramos una parte de la matriz de precios de peajes (en COP) para validar los resultados.

```{r}
round(peajes_matriz[1:5, 1:5], 1)
```

------------------------------------------------------------------------

## Estimación de costos de viaje entre ciudades

#### Cálculo del costo por kilómetro

El costo por kilómetro se calcula con base en los siguientes supuestos:

-   Se asume que el recorrido se realiza en un **Chevrolet Camaro 3.6L V6 modelo 2022**.
-   Este vehículo tiene un consumo combinado estimado de **10.7 litros por cada 100 km**, lo cual corresponde a un rendimiento de aproximadamente **9.35 km por litro**.
-   Se considera un precio promedio de la gasolina de **16,300 COP por galón**, lo que equivale a aproximadamente **4,308 COP por litro**\
    *(1 galón = 3.785 litros)*.

**Cálculo del costo por km:**

$$
\text{Costo por km} = \frac{4,308\ \text{COP}}{9.35\ \text{km/L}} \approx \mathbf{460\ COP\ por\ km}
$$

Este valor se utiliza como base para estimar el gasto en combustible entre cada par de ciudades.

#### Valor por hora del conductor

-   60.000 COP

    -   Se asume que trabaja 200 horas al mes y que esas 200 horas le valen 12.000.000 COP

-   **Combustible** = `distancia * costo_km`

```{r}
costo_km <- 460           # pesos colombianos por kilómetro recorrido
valor_hora <- 60000       # valor hora del vendedor
```

------------------------------------------------------------------------

## Cálculo del costo total entre ciudades

Creamos una matriz con el **costo total** entre cada par de ciudades, donde:

$$
\text{costo_total} = (\text{tiempo} \cdot \text{valor_hora}) + \text{peajes} + (\text{distancia} \cdot \text{costo_km})
$$

En la diagonal principal, el costo será cero porque no hay desplazamiento.

```{r}
costos_matriz <- matrix(0, nrow = ciudades_cantidad, ncol = ciudades_cantidad)
colnames(costos_matriz) <- ciudades_nombres
rownames(costos_matriz) <- ciudades_nombres

for (i in 1:ciudades_cantidad) {
  for (j in 1:ciudades_cantidad) {
    if (i != j) {
      distancia_vial <- distancias_viales_matriz[i, j]
      horas <- horas_matriz[i, j]
      costo_peaje <- peajes_matriz[i, j]
      combustible <- distancia_vial * costo_km
      
      costos_matriz[i, j] <- horas * valor_hora + costo_peaje + combustible
    }
  }
}
```

### Visualización parcial de la matriz de costos

```{r}
round(costos_matriz[1:5, 1:5], 0)
```

### Observaciones

-   Esta matriz de costos será usada en los algoritmos de optimización: algoritmos genéticos y colonias de hormigas para minimizar el costo total del recorrido.

------------------------------------------------------------------------

## Algoritmo Genético para el Problema del Viajero (TSP)

Implementaremos un algoritmo genético (GA) para minimizar el costo total del recorrido entre ciudades.

### Parámetros del algoritmo

```{r}
generaciones_cantidad <- 200
poblacion_cantidad <- 100
tasa_mutacion <- 0.1
```

### Función para evaluar una ruta

Dado un vector con el orden de las ciudades, esta función suma los costos entre ciudades consecutivas.

```{r}
evaluar_ruta <- function(ruta, matriz_costos) {

  total <- 0

  for (i in 1:(ciudades_cantidad - 1)) {
    total <- total + matriz_costos[ruta[i], ruta[i + 1]]
  }

  # Regresar a la ciudad inicial
  total <- total + matriz_costos[ruta[ciudades_cantidad], ruta[1]]

  return(total)
}
```

### Función para **selección por torneo**

```{r}
seleccionar_padres_por_torneo <- function(poblacion, puntajes) {

  padres <- vector("list", poblacion_cantidad)
  
  for (i in 1:poblacion_cantidad) {
    torneo <- sample(1:poblacion_cantidad, 2)
    if (puntajes[torneo[1]] < puntajes[torneo[2]]) {
      padres[[i]] <- poblacion[[torneo[1]]]
    } else {
      padres[[i]] <- poblacion[[torneo[2]]]
    }
  }
  
  return(padres)
}
```

### Funciones de cruzamiento y mutación

```{r}
cruzar <- function(padre1, padre2) {
  punto <- sample(2:(ciudades_cantidad - 1), 1)
  hijo <- padre1[1:punto]
  hijo <- c(hijo, padre2[!padre2 %in% hijo])
  return(hijo)
}
```

```{r}
mutar <- function(ruta) {
  if (runif(1) < tasa_mutacion) {
    pos <- sample(1:ciudades_cantidad, 2)
    ruta[pos] <- ruta[rev(pos)]
  }
  return(ruta)
}
```

### Función para generar nueva población

```{r}
generar_nueva_poblacion <- function(padres) {
  nueva_poblacion <- list()
  
  for (i in seq(1, poblacion_cantidad, by = 2)) {
    hijo1 <- mutar(cruzar(padres[[i]], padres[[i+1]]))
    hijo2 <- mutar(cruzar(padres[[i+1]], padres[[i]]))
    nueva_poblacion <- c(nueva_poblacion, list(hijo1, hijo2))
  }
  
  return(nueva_poblacion)
}
```

### Implementación del algoritmo genético

```{r}
# Inicializar población
poblacion <- replicate(poblacion_cantidad, sample(ciudades_nombres), simplify = FALSE)

for (gen in 1:generaciones_cantidad) {
  # Evaluar población
  puntajes <- sapply(poblacion, function(ruta) evaluar_ruta(ruta, costos_matriz))

  padres <- seleccionar_padres_por_torneo(poblacion, puntajes)
  poblacion <- generar_nueva_poblacion(padres)
}
```

### Solución final

```{r}
puntajes_finales <- sapply(poblacion, function(ruta) evaluar_ruta(ruta, costos_matriz))
mejor_ruta <- poblacion[[which.min(puntajes_finales)]]
mejor_costo <- min(puntajes_finales)

ruta_legible <- paste(c(mejor_ruta, mejor_ruta[1]), collapse = " → ")
cat("Mejor ruta encontrada:\n", ruta_legible, "\n\n")
cat("Costo total: ", format(mejor_costo, big.mark = ","), "COP\n")
```

------------------------------------------------------------------------

## Visualización del recorrido en un mapa

Graficaremos el recorrido óptimo calculado por el Algoritmo Genetico usando coordenadas geográficas y líneas conectadas.

### Preparación de datos

```{r}
# Se obtienen los índices de las ciudades en el orden de mejor_ruta
indices <- match(mejor_ruta, ciudades_nombres)

# Se extraen y se reordenan las filas según mejor_ruta
ruta_coords <- ciudades[indices, ]

# Se agrega el punto inicial al final para cerrar el ciclo
ruta_coords <- rbind(ruta_coords, ruta_coords[1, ])
```

### Mapa del recorrido óptimo

```{r}
leaflet_output <- addCircleMarkers(
  addPolylines(
    addTiles(
      leaflet(ruta_coords)
    ),
    lng = ~lon, lat = ~lat,
    color = "blue", weight = 2,
    label = paste0("De ", ruta_coords$ciudad[-nrow(ruta_coords)],
                   " a ", ruta_coords$ciudad[-1])
  ),
  lng = ~lon, lat = ~lat,
  label = ~ciudad,
  color = "red", radius = 5,
  fillOpacity = 0.8
)

leaflet_output
```

------------------------------------------------------------------------

## Algoritmo de Colonias de Hormigas (ACO) para el TSP

Este algoritmo simula cómo las hormigas encuentran caminos cortos mediante **feromonas** y **visibilidad** (inverso de la distancia/costo).

###️ Parámetros del algoritmo

```{r}
num_hormigas <- 50
num_iteraciones <- 100
alpha <- 1       # influencia de feromonas
beta <- 5        # influencia de visibilidad (1 / costo)
rho <- 0.5       # tasa de evaporación
Q <- 100         # cantidad de feromona depositada
```

### Inicialización de estructuras

```{r}
# Inicializar feromonas
feromonas <- matrix(1, nrow = ciudades_cantidad, ncol = ciudades_cantidad)
rownames(feromonas) <- ciudades_nombres
colnames(feromonas) <- ciudades_nombres

# Visibilidad (1 / costo), evitando división por cero
visibilidad <- 1 / (costo_matrix + diag(Inf, ciudades_cantidad))
```

### Ciclo principal de ACO

```{r}
mejor_ruta_aco <- NULL
mejor_costo_aco <- Inf

for (iter in 1:num_iteraciones) {
  rutas <- list()
  costos <- numeric(num_hormigas)
  
  for (k in 1:num_hormigas) {
    visitadas <- sample(ciudades_nombres, 1)
    while (length(visitadas) < ciudades_cantidad) {
      actual <- tail(visitadas, 1)
      no_visitadas <- setdiff(ciudades_nombres, visitadas)
      
      probabilidades <- sapply(no_visitadas, function(ciudad) {
        feromona <- feromonas[actual, ciudad]^alpha
        visib <- visibilidad[actual, ciudad]^beta
        feromona * visib
      })
      
      probabilidades <- probabilidades / sum(probabilidades)
      siguiente <- sample(no_visitadas, 1, prob = probabilidades)
      visitadas <- c(visitadas, siguiente)
    }
    rutas[[k]] <- visitadas
    costos[k] <- evaluar_ruta(visitadas, costo_matrix)
    
    if (costos[k] < mejor_costo_aco) {
      mejor_costo_aco <- costos[k]
      mejor_ruta_aco <- visitadas
    }
  }
  
  # Evaporación de feromonas
  feromonas <- (1 - rho) * feromonas
  
  # Depositar nuevas feromonas
  for (k in 1:num_hormigas) {
    ruta <- rutas[[k]]
    for (i in 1:(ciudades_cantidad - 1)) {
      a <- ruta[i]
      b <- ruta[i + 1]
      feromonas[a, b] <- feromonas[a, b] + Q / costos[k]
      feromonas[b, a] <- feromonas[b, a] + Q / costos[k]
    }
    # Conectar final con inicio
    feromonas[ruta[ciudades_cantidad], ruta[1]] <- feromonas[ruta[ciudades_cantidad], ruta[1]] + Q / costos[k]
    feromonas[ruta[1], ruta[ciudades_cantidad]] <- feromonas[ruta[1], ruta[ciudades_cantidad]] + Q / costos[k]
  }
}
```

### Resultado del ACO

```{r}
mejor_ruta_aco
mejor_costo_aco
```

------------------------------------------------------------------------

## Creación del GIF animado

### 1. Preparación de los datos del recorrido

```{r}
# Nos aseguramos de tener el mejor recorrido
ruta <- mejor_ruta_aco
coords <- ciudades[match(ruta, ciudades$ciudad), ]

# Agregar punto de retorno al inicio
coords <- rbind(coords, coords[1, ])

# Crear data.frame animable paso a paso
anim_data <- data.frame()
for (i in 2:nrow(coords)) {
  paso <- coords[1:i, ]
  paso$frame <- i - 1
  paso$orden <- 1:nrow(paso)
  anim_data <- rbind(anim_data, paso)
}
```

### 2. Creación de la animación punto por punto

```{r}
p <- ggplot(anim_data, aes(x = lon, y = lat)) +
  borders("world", regions = "Colombia", fill = "gray95", colour = "gray60") +
  geom_path(aes(group = frame), color = "blue", linewidth = 1) +
  geom_point(color = "red", size = 3) +
  geom_text(aes(label = ciudad), vjust = -1, size = 3) +
  labs(title = "Recorrido óptimo - Paso: {frame}") +
  coord_fixed(1.3) +
  theme_minimal()

anim <- p + transition_manual(frames = frame)

anim_save(
  "recorrido_paso_a_paso.gif", 
  animation = anim, 
  renderer = gifski_renderer(),
  width = 832,   # ancho en píxeles
  height = 1080,  # alto en píxeles
  units = "px"
)
```
